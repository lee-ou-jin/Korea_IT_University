"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resource = void 0;
const adminjs_1 = require("adminjs");
const ResourceInfo_1 = require("../info/ResourceInfo");
const object_1 = require("../utils/object");
class Resource extends adminjs_1.BaseResource {
    constructor(info) {
        super(info.tableName);
        this.propertyMap = new Map();
        this.knex = info.knex;
        this.tableName = info.tableName;
        this._databaseName = info.databaseName;
        this._properties = info.properties;
        this._properties.forEach((p) => {
            this.propertyMap.set(p.path(), p);
        });
        this.idColumn = info.idProperty.columnName;
    }
    static isAdapterFor(resource) {
        const r = resource instanceof ResourceInfo_1.ResourceInfo;
        if (!r) {
            if (Array.isArray(resource) && resource[0] instanceof ResourceInfo_1.ResourceInfo) {
                throw new Error('resource is an array. Did you forgot `...` before `db.tables()`?');
            }
        }
        return r;
    }
    databaseName() {
        return this._databaseName;
    }
    databaseType() {
        return 'MySQL';
    }
    id() {
        return this.tableName;
    }
    properties() {
        return this._properties;
    }
    property(path) {
        var _a;
        return (_a = this.propertyMap.get(path)) !== null && _a !== void 0 ? _a : null;
    }
    count(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const [r] = yield this.filterQuery(filter).count('* as cnt');
            return r.cnt;
        });
    }
    find(filter, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.filterQuery(filter);
            if (options.limit) {
                query.limit(options.limit);
            }
            if (options.offset) {
                query.offset(options.offset);
            }
            if ((_a = options.sort) === null || _a === void 0 ? void 0 : _a.sortBy) {
                query.orderBy(options.sort.sortBy, options.sort.direction);
            }
            const rows = yield query;
            return rows.map((row) => new adminjs_1.BaseRecord(row, this));
        });
    }
    findOne(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.knex(this.tableName).where(this.idColumn, id);
            return res[0] ? this.build(res[0]) : null;
        });
    }
    findMany(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.knex(this.tableName).whereIn(this.idColumn, ids);
            return res.map((r) => this.build(r));
        });
    }
    build(params) {
        return new adminjs_1.BaseRecord(params, this);
    }
    create(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const [id] = yield this.knex(this.tableName).insert((0, object_1.undefinedToNull)(params));
            const [row] = yield this.knex(this.tableName).where(this.idColumn, id);
            return row;
        });
    }
    update(id, params) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.knex
                .from(this.tableName)
                .update((0, object_1.undefinedToNull)(params))
                .where(this.idColumn, id);
            const [row] = yield this.knex(this.tableName).where(this.idColumn, id);
            return row;
        });
    }
    delete(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.knex.from(this.tableName).delete().where(this.idColumn, id);
        });
    }
    filterQuery(filter) {
        const q = this.knex(this.tableName);
        if (!filter) {
            return q;
        }
        const { filters } = filter;
        Object.entries(filters !== null && filters !== void 0 ? filters : {}).forEach(([key, filter]) => {
            if (typeof filter.value === 'object') {
                q.whereBetween(key, [filter.value.from, filter.value.to]);
            }
            else {
                q.where(key, filter.value);
            }
        });
        return q;
    }
}
exports.Resource = Resource;
//# sourceMappingURL=Resource.js.map